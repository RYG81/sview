/**
 * Copyright Â© 2011-2012 Kirill Gavrilov <kirill@sview.ru>
 *
 * StCore library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * StCore library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#if (defined(__APPLE__))

#include "StCocoaView.h"
#include "StWindowImpl.h"
#include "stvkeyscarbon.h"

#include <StStrings/StLogger.h>
#include <StTemplates/StRect.h>

@implementation StCocoaView

    - (id ) initWithStWin: (StWindowImpl* ) theStWin
                    nsWin: (NSWindow* )     theNsWin {
        NSRect aBounds = [[theNsWin contentView] bounds];
        self = [super initWithFrame: aBounds
                        pixelFormat: [[NSOpenGLView class] defaultPixelFormat]];
        if(self == NULL) {
            return NULL;
        }
        myStWin = theStWin;

        // setup fullscreen options
        NSString* aKeys[] = {
            NSFullScreenModeSetting,
            NSFullScreenModeWindowLevel // we override window level here, needed for slave window
        };
        NSNumber* aValues[] = {
            [NSNumber numberWithBool:    YES],
            [NSNumber numberWithInteger: kCGMaximumWindowLevel]
        };
        myFullScrOpts = [[NSDictionary alloc] initWithObjects: aValues
                                                      forKeys: aKeys
                                                        count: 2];

        // register Drag & Drop supports
        NSArray* aDndTypes = [NSArray arrayWithObjects: NSFilenamesPboardType, NULL];
        [self registerForDraggedTypes: aDndTypes];

        // replace content view in the window
        [theNsWin setContentView: self];

        // make view as first responder in winow to capture all useful events
        [theNsWin makeFirstResponder: self];
        return self;
    }

    - (void ) dealloc {
        [myFullScrOpts release];
        [super dealloc];
    }

    /*- (void ) reshape {
        // wait until view is redrawn in another thread
        ///myStWin->TheEvent.reset();
        ///myStWin->TheEvent.wait(1000);
        [super reshape];
        myStWin->myMessageList.append(StMessageList::MSG_RESIZE);
    }*/

    /**
     * Left mouse button - down.
     */
    - (void ) mouseDown: (NSEvent* ) theEvent {
        myStWin->myMDownQueue.push(myStWin->getMousePos(), ST_MOUSE_LEFT);
        myStWin->myMessageList.append(StMessageList::MSG_MOUSE_DOWN);
    }

    /**
     * Left mouse button - up.
     */
    - (void ) mouseUp: (NSEvent* ) theEvent {
        myStWin->myMUpQueue.push(myStWin->getMousePos(), ST_MOUSE_LEFT);
        myStWin->myMessageList.append(StMessageList::MSG_MOUSE_UP);
    }

    /**
     * Right mouse button - down.
     */
    - (void ) rightMouseDown: (NSEvent* ) theEvent {
        myStWin->myMDownQueue.push(myStWin->getMousePos(), ST_MOUSE_RIGHT);
        myStWin->myMessageList.append(StMessageList::MSG_MOUSE_DOWN);
    }

    /**
     * Right mouse button - up.
     */
    - (void ) rightMouseUp: (NSEvent* ) theEvent {
        myStWin->myMUpQueue.push(myStWin->getMousePos(), ST_MOUSE_RIGHT);
        myStWin->myMessageList.append(StMessageList::MSG_MOUSE_UP);
    }

    /**
     * Another (nor left nor right) mouse button - down.
     */
    - (void ) otherMouseDown: (NSEvent* ) theEvent {
        int aBtnId = ST_NOMOUSE;
        if([theEvent buttonNumber] == 2) {
            aBtnId = ST_MOUSE_MIDDLE;
        }
        if(aBtnId != ST_NOMOUSE) {
            myStWin->myMDownQueue.push(myStWin->getMousePos(), aBtnId);
            myStWin->myMessageList.append(StMessageList::MSG_MOUSE_DOWN);
        }
    }

    /**
     * Another (nor left nor right) mouse button - up.
     */
    - (void ) otherMouseUp: (NSEvent* ) theEvent {
        int aBtnId = ST_NOMOUSE;
        if([theEvent buttonNumber] == 2) {
            aBtnId = ST_MOUSE_MIDDLE;
        }
        if(aBtnId != ST_NOMOUSE) {
            myStWin->myMUpQueue.push(myStWin->getMousePos(), aBtnId);
            myStWin->myMessageList.append(StMessageList::MSG_MOUSE_UP);
        }
    }

    /**
     * Mouse scroll.
     */
    - (void ) scrollWheel: (NSEvent* ) theEvent {
        // TODO (Kirill Gavrilov#9#) delta ignored
        if(stAreEqual([theEvent deltaY], 0.0, 0.001)) {
            // a lot of values near zero can be generated by touchpad
            return;
        }
        int aBtnId = ([theEvent deltaY] > 0.0) ? ST_MOUSE_SCROLL_V_UP : ST_MOUSE_SCROLL_V_DOWN;
        StPointD_t aPoint = myStWin->getMousePos();
        myStWin->myMDownQueue.push(aPoint, aBtnId);
        myStWin->myMessageList.append(StMessageList::MSG_MOUSE_DOWN);
        myStWin->myMUpQueue.push(aPoint, aBtnId);
        myStWin->myMessageList.append(StMessageList::MSG_MOUSE_UP);
    }

    /**
     * Keyboard shortcuts event.
     */
    /**- (BOOL ) performKeyEquivalent: (NSEvent* ) theEvent {
        unsigned short aKeyCode = [theEvent keyCode];
        ST_DEBUG_LOG("performKeyEquivalent " + aKeyCode);
        if(aKeyCode >= ST_CARBON2ST_VK_SIZE) {
            ST_DEBUG_LOG("performKeyEquivalent, keycode= " + aKeyCode + " ignored!\n");
            return NO;
        }
        return NO;
    }*/

    /**
     * Modifier key pressed.
     */
    - (void ) flagsChanged: (NSEvent* ) theEvent {
        NSUInteger aFlags = [theEvent modifierFlags];
        myStWin->myMessageList.getKeysMap()[ST_VK_CONTROL] = (aFlags & NSControlKeyMask);
        myStWin->myMessageList.getKeysMap()[ST_VK_SHIFT]   = (aFlags & NSShiftKeyMask);
    }

    /**
     * Key down event.
     */
    - (void ) keyDown: (NSEvent* ) theEvent {
        unsigned short aKeyCode = [theEvent keyCode];
        if(aKeyCode >= ST_CARBON2ST_VK_SIZE) {
            ST_DEBUG_LOG("keyDown, keycode= " + aKeyCode + " ignored!\n");
            return;
        }

        NSUInteger aFlags = [theEvent modifierFlags];
        if(aFlags & NSCommandKeyMask) {
            return; // ignore Command + key combinations - key up event doesn't called!
        }
        myStWin->myMessageList.getKeysMap()[ST_CARBON2ST_VK[aKeyCode]] = true;
    }

    /**
     * Key up event.
     */
    - (void ) keyUp: (NSEvent* ) theEvent {
        unsigned short aKeyCode = [theEvent keyCode];
        if(aKeyCode >= ST_CARBON2ST_VK_SIZE) {
            ST_DEBUG_LOG("keyUp,   keycode= " + aKeyCode + " ignored!\n");
            return;
        }
        myStWin->myMessageList.getKeysMap()[ST_CARBON2ST_VK[aKeyCode]] = false;
    }

    - (void ) goToFullscreen {
        if(![self isInFullScreenMode]) {
            [self enterFullScreenMode: [[self window] screen] withOptions: myFullScrOpts];
        }
    }

    - (void ) goToWindowed {
        if([self isInFullScreenMode]) {
            [self exitFullScreenModeWithOptions: myFullScrOpts];
            [[self window] makeFirstResponder: self];
        }
    }

    - (NSDragOperation ) draggingEntered: (id <NSDraggingInfo> ) theSender {
        if((NSDragOperationGeneric & [theSender draggingSourceOperationMask]) == NSDragOperationGeneric) {
            return NSDragOperationGeneric;
        }
        // not a drag we can use
        return NSDragOperationNone;
    }

    - (void ) draggingExited: (id <NSDraggingInfo> ) theSender {
        //
    }

    - (BOOL ) prepareForDragOperation: (id <NSDraggingInfo> ) theSender {
        return YES;
    }

    - (BOOL ) performDragOperation: (id <NSDraggingInfo> ) theSender {
        NSPasteboard* aPasteBoard = [theSender draggingPasteboard];
        if([[aPasteBoard types] containsObject: NSFilenamesPboardType]) {
            NSArray* aFiles = [aPasteBoard propertyListForType: NSFilenamesPboardType];
            int aFilesCount = [aFiles count];
            if(aFilesCount < 1) {
                return NO;
            }

            myStWin->myDndMutex.lock();
            myStWin->myDndCount = aFilesCount;
            delete[] myStWin->myDndList;
            myStWin->myDndList = new StString[myStWin->myDndCount];
            for(NSUInteger aFileId = 0; aFileId < [aFiles count]; ++aFileId) {
                NSString* aFilePathNs = (NSString* )[aFiles objectAtIndex: aFileId];
                if(aFilePathNs == NULL
                || [aFilePathNs isKindOfClass: [NSString class]] == NO) {
                    continue;
                }
                // automatically convert filenames from decomposed form used by Mac OS X file systems
                myStWin->myDndList[aFileId] = StString([[aFilePathNs precomposedStringWithCanonicalMapping] UTF8String]);
            }
            myStWin->myDndMutex.unlock();
            myStWin->myMessageList.append(StMessageList::MSG_DRAGNDROP_IN);
        }
        return YES;
    }

@end

#endif // __APPLE__
